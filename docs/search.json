[{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"what-are-scan-statistics","dir":"Articles","previous_headings":"","what":"What are scan statistics?","title":"Introduction to scanstatistics","text":"Scan statistics used detect anomalous clusters spatial space-time data. gist methodology, least package, : Monitor one data streams multiple locations intervals time. Form set space-time clusters, consisting (1) collection locations, (2) interval time stretching present number time periods past. cluster, compute statistic based observed expected responses. Report clusters largest statistics.","code":""},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"scan-statistics","dir":"Articles","previous_headings":"Main functions","what":"Scan statistics","title":"Introduction to scanstatistics","text":"scan_eb_poisson: computes expectation-based Poisson scan statistic (Neill et al. 2005). scan_pb_poisson: computes (population-based) space-time scan statistic (Kulldorff 2001). scan_eb_negbin: computes expectation-based negative binomial scan statistic (Tango, Takahashi, Kohriyama 2011). scan_eb_zip: computes expectation-based zero-inflated Poisson scan statistic (Allévius Höhle 2017). scan_permutation: computes space-time permutation scan statistic (Kulldorff et al. 2005). scan_bayes_negbin: computes Bayesian Spatial scan statistic (Neill, Moore, Cooper 2006), extended space-time setting.","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"zone-creation","dir":"Articles","previous_headings":"Main functions","what":"Zone creation","title":"Introduction to scanstatistics","text":"coords_to_knn: use stats::dist get \\(k\\) nearest neighbors location format usable knn_zones. dist_to_knn: use already computed distance matrix get \\(k\\) nearest neighbors location format usable knn_zones. flexible_zones: alternative knn_zones uses adjacency structure locations create richer set zones. additional input adjacency matrix, otherwise works knn_zones.","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"miscellaneous","dir":"Articles","previous_headings":"Main functions","what":"Miscellaneous","title":"Introduction to scanstatistics","text":"score_locations: Score location likely ongoing anomaly . score heuristically motivated. top_clusters: Get top \\(k\\) space-time clusters, either overlapping non-overlapping spatial dimension. df_to_matrix: Convert data frame data location time point matrix locations along column dimension time along row dimension, selected data values.","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"example-brain-cancer-in-new-mexico","dir":"Articles","previous_headings":"","what":"Example: Brain cancer in New Mexico","title":"Introduction to scanstatistics","text":"demonstrate scan statistics package, use dataset annual number brain cancer cases counties New Mexico, years 1973-1991. data studied Kulldorff et al. (1998), detected cluster cancer cases counties Los Alamos Santa Fe years 1986-1989, though excess brain cancer cluster deemed statistically significant. data originally comes package rsatscan (Kleinman 2015), provides interface program SaTScan, aggregated extended scanstatistics package. get familiar counties New Mexico, begin plotting map using data frames NM_map NM_geo supplied scanstatistics package:  can obtain yearly number cases population country years 1973-1991 data table NM_popcas provided package: noted Cibola county split Valencia county 1981, cases Cibola counted Valencia data.","code":"library(scanstatistics) library(ggplot2) ## Registered S3 method overwritten by 'ggplot2': ##   method        from ##   print.element sets # Load map data data(NM_map) data(NM_geo)  # Plot map with labels at centroids ggplot() +    geom_polygon(data = NM_map,                mapping = aes(x = long, y = lat, group = group),                color = \"grey\", fill = \"white\") +   geom_text(data = NM_geo,              mapping = aes(x = center_long, y = center_lat, label = county)) +   ggtitle(\"Counties of New Mexico\") data(NM_popcas) head(NM_popcas) ##   year     county population count ## 1 1973 bernalillo     353813    16 ## 2 1974 bernalillo     357520    16 ## 3 1975 bernalillo     368166    16 ## 4 1976 bernalillo     378483    16 ## 5 1977 bernalillo     388471    15 ## 6 1978 bernalillo     398130    18"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"a-scan-statistic-for-poisson-data","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico","what":"A scan statistic for Poisson data","title":"Introduction to scanstatistics","text":"Poisson distribution natural first option dealing count data. scanstatistics package provides two functions scan_eb_poisson scan_pb_poisson distributional assumption. first expectation-based1 scan statistic univariate Poisson-distributed data proposed Neill et al. (2005), focus one example . second scan statistic population-based scan statistic proposed Kulldorff (2001).","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"theoretical-motivation","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Theoretical motivation","title":"Introduction to scanstatistics","text":"expectation-based Poisson scan statistic, null hypothesis anomaly states location \\(\\) duration \\(t\\), observed count Poisson-distributed expected value \\(\\mu_{}\\): \\[  H_0 \\! : Y_{} \\sim \\textrm{Poisson}(\\mu_{}), \\] locations \\(=1,\\ldots,m\\) durations \\(t=1,\\ldots,T\\), \\(T\\) maximum duration considered. alternative hypothesis, space-time cluster \\(W\\) consisting spatial zone \\(Z \\subset \\{1,\\ldots,m\\}\\) time window \\(D = \\{1, 2, \\ldots, d\\} \\subseteq \\{1,2,\\ldots,T\\}\\) counts \\(W\\) expected values inflated factor \\(q_W > 1\\) compared null hypothesis: \\[ H_1 \\! : Y_{} \\sim \\textrm{Poisson}(q_W \\mu_{}), ~~(,t) \\W. \\] locations durations outside window, counts assumed distributed null hypothesis. Calculating scan statistic involves three steps: space-time window \\(W\\), find maximum likelihood estimate \\(q_W\\), treating \\(\\mu_{}\\)’s constants. Plug estimated \\(q_W\\) (logarithm ) likelihood ratio likelihood alternative hypothesis numerator likelihood null hypothesis (\\(q_W=1\\)) denominator, \\(W\\). Take scan statistic maximum likelihood ratios, corresponding window \\(W^*\\) likely cluster (MLC).","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"using-the-poisson-scan-statistic","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Using the Poisson scan statistic","title":"Introduction to scanstatistics","text":"first argument scan statistics package matrix (array) observed counts, whether integer counts real-valued “counts.” matrix, columns represent locations rows time intervals, ordered chronologically earliest interval first row recent last. example like detect potential cluster brain cancer counties New Mexico years 1986-1989, begin retrieving count population data period reshaping matrix using helper function df_to_matrix:","code":"library(dplyr) ##  ## Attaching package: 'dplyr' ## The following objects are masked from 'package:stats': ##  ##     filter, lag ## The following objects are masked from 'package:base': ##  ##     intersect, setdiff, setequal, union counts <- NM_popcas %>%    filter(year >= 1986 & year < 1990) %>%   df_to_matrix(time_col = \"year\", location_col = \"county\", value_col = \"count\")"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"spatial-zones","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Spatial zones","title":"Introduction to scanstatistics","text":"second argument scan_eb_poisson list integer vectors, vector zone, name spatial component potential outbreak cluster. zone consists one locations grouped together according similarity across features, location numbered corresponding column index counts matrix (indexing starts 1). example, locations counties New Mexico features coordinates county seats. made available data table NM_geo. Similarity measured using geographical distance seats counties, taking account curvature earth. distance matrix calculated using spDists function sp package, passed dist_to_knn (\\(k=15\\) neighbors) knn_zones:","code":"library(sp) library(magrittr)  # Remove Cibola since cases have been counted towards Valencia. Ideally, this # should be accounted for when creating the zones. zones <- NM_geo %>%   filter(county != \"cibola\") %>%   select(seat_long, seat_lat) %>%   as.matrix %>%   spDists(x = ., y = ., longlat = TRUE) %>%   dist_to_knn(k = 15) %>%   knn_zones"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"baselines","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Baselines","title":"Introduction to scanstatistics","text":"advantage expectation-based scan statistics parameters expected value can modelled estimated past data e.g. form regression. expectation-based Poisson scan statistic, can use (simple) Poisson GLM estimate expected value count county year, accounting different populations region. Similar counts argument, expected values passed matrix scan_eb_poisson function: Note population numbers (perhaps poorly) interpolated censuses conducted 1973, 1982, 1991.","code":"mod <- glm(count ~ offset(log(population)) + 1 + I(year - 1985),            family = poisson(link = \"log\"),            data = NM_popcas %>% filter(year < 1986))  ebp_baselines <- NM_popcas %>%    filter(year >= 1986 & year < 1990) %>%   mutate(mu = predict(mod, newdata = ., type = \"response\")) %>%   df_to_matrix(value_col = \"mu\")"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"calculation","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Calculation","title":"Introduction to scanstatistics","text":"can now calculate Poisson scan statistic. give us confidence detection results, perform 999 Monte Carlo replications, data generated using parameters null hypothesis new scan statistic calculated. summarized \\(P\\)-value, calculated proportion times replicated scan statistics exceeded observed one. output scan_poisson object class “scanstatistic,” comes print method seen . can see, likely cluster anomaly stretches 1986-1989 involves locations numbered 15 26, correspond counties counties detected Kulldorff et al. (1998), though analysis retrospective rather prospective . also data dredging used study period hopes detecting cluster.","code":"set.seed(1) poisson_result <- scan_eb_poisson(counts = counts,                                    zones = zones,                                    baselines = ebp_baselines,                                   n_mcsim = 999) print(poisson_result) ## Data distribution:                Poisson ## Type of scan statistic:           expectation-based ## Setting:                          univariate ## Number of locations considered:   32 ## Maximum duration considered:      4 ## Number of spatial zones:          415 ## Number of Monte Carlo replicates: 999 ## Monte Carlo P-value:              0.005 ## Gumbel P-value:                   NULL ## Most likely event duration:       4 ## ID of locations in MLC:           15, 26 counties <- as.character(NM_geo$county) counties[c(15, 26)] [1] \"losalamos\" \"santafe\""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"a-heuristic-score-for-locations","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"A heuristic score for locations","title":"Introduction to scanstatistics","text":"can score county according likely part cluster heuristic fashion using function score_locations, visualize results heatmap follows:  warning though: score_locations function can quite slow large data sets. might change future versions package.","code":"# Calculate scores and add column with county names county_scores <- score_locations(poisson_result, zones) county_scores %<>% mutate(county = factor(counties[-length(counties)],                                            levels = levels(NM_geo$county)))  # Create a table for plotting score_map_df <- merge(NM_map, county_scores, by = \"county\", all.x = TRUE) %>%   arrange(group, order)  # As noted before, Cibola county counts have been attributed to Valencia county score_map_df[score_map_df$subregion == \"cibola\", ] %<>%   mutate(relative_score = score_map_df %>%                            filter(subregion == \"valencia\") %>%                            select(relative_score) %>%                            .[[1]] %>% .[1])  ggplot() +    geom_polygon(data = score_map_df,                mapping = aes(x = long, y = lat, group = group,                               fill = relative_score),                color = \"grey\") +   scale_fill_gradient(low = \"#e5f5f9\", high = \"darkgreen\",                       guide = guide_colorbar(title = \"Relative\\nScore\")) +   geom_text(data = NM_geo,              mapping = aes(x = center_long, y = center_lat, label = county),             alpha = 0.5) +   ggtitle(\"County scores\")"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"finding-the-top-scoring-clusters","dir":"Articles","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Finding the top-scoring clusters","title":"Introduction to scanstatistics","text":"Finally, want know just likely cluster, say five top-scoring space-time clusters, can use function top_clusters. clusters returned can either overlapping non-overlapping spatial dimension, according liking. top_clusters function includes Monte Carlo Gumbel \\(P\\)-values cluster. \\(P\\)-values conservative, since secondary clusters original data compared likely clusters replicate data sets.","code":"top5 <- top_clusters(poisson_result, zones, k = 5, overlapping = FALSE)  # Find the counties corresponding to the spatial zones of the 5 clusters. top5_counties <- top5$zone %>%   purrr::map(get_zone, zones = zones) %>%   purrr::map(function(x) counties[x])  # Add the counties corresponding to the zones as a column top5 %<>% mutate(counties = top5_counties)"},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"concluding-remarks","dir":"Articles","previous_headings":"","what":"Concluding remarks","title":"Introduction to scanstatistics","text":"univariate scan statistics can calculated practically way , though distribution parameters need adapted scan statistic.","code":""},{"path":"https://promerpr.github.io/scanstatistics/articles/introduction.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"Introduction to scanstatistics","text":"think package lacks functionality, something needs better documentation, please open issue . ’m also interested applying methods package (current future) new problems, know suitable public datasets, please tell ! dataset multivariate response (e.g. multiple counter variables) particular interest.","code":""},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/articles/make_data.html","id":"process-the-brain-cancer-data","dir":"Articles","previous_headings":"","what":"Process the brain cancer data","title":"Process data","text":"file shows reshape New Mexico brain cancer data R package rsatscan (Kleinman 2015) format suitable scanstatistics package. begin loading needed packages data, comes three data frames: Cibola: county split Valencia 1981, cases Cibola counted Valencia data. Cibola present data frames either. Harding: county present two data frames. replace case values Harding 0, assumed number cases since county small population. NM_pop: exception Cibola county, data frame contains population count counties, age groups, gender category years 1973, 1982, 1991. NM_geo: contains longitude latitude county’s seat (administrative center). Since coordinates provided rsatscan package needed format, grab coordinates Wikipedia article instead, replace data frame. get familiar counties New Mexico, let’s plot map:  proceeding, make changes data ensure counties named across tables. main functions scanstatistic package require locations encoded integers. Thus make county names factor variable, integer vectors additional attributes. levels factor also present data. Scan statistics aim find localized anomalies data, meaning locations timepoints involved anomaly close together way. example, use geographic centroids (calculated ), lots distance measures work just well. let’s grab coordinates county seats Wikipedia plot . Kudos Cory Nissen blogpost, shows fetch data table Wikipedia.  scan statistic functions package work, locations timepoints zero counts must filled , left . Thus, add needed zeros case data. consider total number cancer cases county year, also take oppotunity aggregate case counts age group sex: demonstrate scan statistic methods package, try detect brain cancer clusters years 1986–1989, using data previous years predict many cancer cases can expect see anomalous increase incidence. particular example, want use available population size data offsets predicted means, order properly compare occurence cancer different counties. Since population counts available three years, interpolate population remaining years fitting quadratic function time population data county aggregating number cancer cases age group gender1. Though leads unrealistically smooth population changes, adequate purpose demonstrating functions scanstatistics package. Finally, join population case tables plot number cases evolve county years:  data tables NM_popcas, NM_geo NM_map saved available scanstatistics package, converting data frames:","code":"knitr::opts_chunk$set(message = FALSE, warning = FALSE) library(rsatscan) library(data.table)  NM_pop <- as.data.table(rsatscan::NMpop) NM_cas <- as.data.table(rsatscan::NMcas) library(ggplot2) library(magrittr) library(dplyr)  # Grab polygon data for plotting NM_map <- map_data(\"county\", \"new mexico\")  # Calculate geographical centroids from a polygon # See: https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon polygon_centroid <- function(x0, y0) {   x1 <- c(x0[-1], x0[1])   y1 <- c(y0[-1], y0[1])   A <- sum(x0 * y1 - x1 * y0) / 2   Cx <- sum((x0 + x1) * (x0 * y1 - x1 * y0)) / (6 * A)   Cy <- sum((y0 + y1) * (x0 * y1 - x1 * y0)) / (6 * A)   c(long = Cx, lat = Cy) } pgc <- function(df) polygon_centroid(as.numeric(df$long), as.numeric(df$lat))  centroids <- data.frame(subregion = unique(NM_map$subregion), long = NA, lat = NA)  # Calculate geographic centroids for each county for (i in 1:nrow(centroids)) {   centroids[i, c(\"long\", \"lat\")] <- NM_map %>%     filter(subregion == centroids$subregion[i]) %>%     pgc }  # Plot map with labels at centroids ggplot() +    geom_polygon(data = NM_map,                mapping = aes(x = long, y = lat, group = group),                color = \"white\", fill = \"grey\") +   geom_text(data = centroids,              mapping = aes(x = long, y = lat, label = subregion)) +   ggtitle(\"Counties of New Mexico\") +   theme_bw() library(stringr) # library(plyr, warn.conflicts = FALSE)  # This function corrects inconsistencies in the county names format_counties <- function(x) {   x %>%     tolower %>%     str_replace_all(pattern = \" \", replacement = \"\") %>%     str_replace_all(pattern = \"ñ\", replacement = \"n\") %>%     str_replace_all(pattern = \"guadelupe\", replacement = \"guadalupe\") }  # Make the county factor variable all_counties <- NM_map$subregion %>%   unique %>%   format_counties %>%   as.factor  # Character vector without Cibola county counties <- levels(all_counties)[-which(levels(all_counties) == \"cibola\")]  # This function corrects inconsistencies in x and makes it into a factor factorize_counties <- function(x, fac = counties) {   x %>%     format_counties %>%     factor(levels = c(fac, \"cibola\")) }  # Fix inconsistencies and factorize counties in the data centroids %<>%    mutate(county = format_counties(subregion),          county = factorize_counties(county),          center_long = long, center_lat = lat,          long = NULL, lat = NULL,          subregion = NULL) NM_cas %<>% mutate(county = factorize_counties(county)) %>% as.data.table NM_pop %<>% mutate(county = factorize_counties(county)) NM_map %<>% mutate(county = factorize_counties(subregion)) %>% as.data.table NM_pop %<>% mutate(year = year + 1900) %>% as.data.table library(rvest)  # Function to clean table entries clean_entry <- function(x) {   x %>%     gsub(\"\\\\d+♠\", \"\",  .) %>%      gsub(\"^[^\\\\(]+\\\\(\", \"\", .) %>%     gsub(\"\\\\,\", \"\", .) %>%     str_split(pattern = \"[:blank:]\") %>%     lapply(function(x) x[1]) %>%     unlist %>%     as.numeric     # gsub(\"\\\\ [:alpha:]+\", \"\", .)     # gsub(\"\\ km2\\\\)\", \"\", .) %>%     # gsub(\"\\ km²\\\\)\", \"\", .) }  # Grab the table from Wikipedia (as at 2022-04-15) seat_url <- \"https://en.wikipedia.org/wiki/List_of_counties_in_New_Mexico\" NM_geo <- seat_url %>%   read_html %>%   rvest::html_nodes(xpath = '//*[@id=\"mw-content-text\"]/div/table[3]') %>%   html_table %>%   .[[1]] %>%   select(County, `County seat[3]`, `Pop.[6]`, `Area[3][7]`) %>%   rename(county = County,           seat = `County seat[3]`,           population = `Pop.[6]`,           `area(km2)` = `Area[3][7]`) %>%   mutate_at(.vars = c(\"population\", \"area(km2)\"), .funs = clean_entry) %>%   mutate(county = gsub(\" County\", \"\", county)) %>%   mutate(county = factorize_counties(county, counties)) %>%   as.data.table   # Get the coordinates for the New Mexico county seats using ggmap::geocode get_NM_longlat <- function(seats) {   suppressMessages({     res <- t(sapply(seats, function(x) t(ggmap::geocode(paste0(x, \", New Mexico\")))))   })   data.frame(seat_long = res[, 1], seat_lat = res[, 2]) }  NM_geo <- cbind(NM_geo, get_NM_longlat(NM_geo$seat)) NM_geo <- merge(NM_geo, centroids, by = \"county\")  ggplot() +    geom_polygon(data = NM_map,                mapping = aes(x = long, y = lat, group = group),                color = \"white\", fill = \"grey\") +   geom_point(data = NM_geo,               mapping = aes(x = seat_long, y = seat_lat)) +   ggtitle(\"County seats of New Mexico\") +   theme_bw() # Aggregate population and cases over sex and age group NM_cas <- NM_cas[, .(count = sum(cases)), by = .(year, county)] NM_pop <- NM_pop[, .(population = sum(population)), by = .(year, county)]  # Create the complete, sorted table of counties, years, age groups, and sex combo_YC <- as.data.table(expand.grid(year = unique(NM_cas$year),                                        county = counties))  # Set keys for merge setkeyv(NM_cas, c(\"year\", \"county\")) setkeyv(NM_pop, c(\"year\", \"county\")) setkeyv(combo_YC, c(\"year\", \"county\"))  # Merge data NM_cas <- merge(NM_cas, combo_YC, all = TRUE) NM_pop <- merge(NM_pop, combo_YC, all = TRUE)  # Fill in zero case counts NM_cas[is.na(count), count := 0] NM_pop[, population := as.numeric(population)]  # Interpolate county populations for (s in counties) {   pop_mod <- lm(population ~ 1 + I(scale(year)) + I(scale(year)^2),                  data = NM_pop[county == s, ])   pop_pred <- predict(pop_mod, NM_pop[is.na(population) & county == s, ],                        type = \"response\")   NM_pop[is.na(population) & county == s, population := pop_pred] } NM_popcas <- merge(NM_pop, NM_cas) setkeyv(NM_popcas, c(\"county\", \"year\"))  ggplot(NM_popcas) + geom_line(aes(x = year, y = count, color = county)) +   theme(legend.position = \"none\") NM_popcas %<>% as.data.frame NM_geo %<>% as.data.frame NM_map %<>% as.data.frame"},{"path":"https://promerpr.github.io/scanstatistics/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Benjamin Allévius. Author. Paul Romer Present. Contributor, maintainer.","code":""},{"path":"https://promerpr.github.io/scanstatistics/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"AllÃ©vius B (2018). “scanstatistics: space-time anomaly detection using scan statistics.” Journal Open Source Software, 3(25), 515. doi: 10.21105/joss.00515.","code":"@Article{,   author = {Benjamin Allévius},   title = {scanstatistics: space-time anomaly detection using scan statistics},   journal = {Journal of Open Source Software},   year = {2018},   volume = {3},   number = {25},   pages = {515},   doi = {10.21105/joss.00515}, }"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"scanstatistics","dir":"","previous_headings":"","what":"Space-Time Anomaly Detection using Scan Statistics","title":"Space-Time Anomaly Detection using Scan Statistics","text":"R package space-time anomaly detection using scan statistics.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"installing-the-package","dir":"","previous_headings":"","what":"Installing the package","title":"Space-Time Anomaly Detection using Scan Statistics","text":"install latest (CRAN) release package, type following: install development version package, type instead:","code":"install.packages(\"scanstatistics\") devtools::install_github(\"promerpr/scanstatistics\", ref = \"develop\")"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"what-are-scan-statistics","dir":"","previous_headings":"","what":"What are scan statistics?","title":"Space-Time Anomaly Detection using Scan Statistics","text":"Scan statistics used detect anomalous clusters spatial space-time data. gist methodology, least package, : Monitor one data streams multiple locations intervals time. Form set space-time clusters, consisting (1) collection locations, (2) interval time stretching present number time periods past. cluster, compute statistic based observed expected responses. Report clusters largest statistics.","code":""},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"scan-statistics","dir":"","previous_headings":"Main functions","what":"Scan statistics","title":"Space-Time Anomaly Detection using Scan Statistics","text":"scan_eb_poisson: computes expectation-based Poisson scan statistic (Neill 2005). scan_pb_poisson: computes (population-based) space-time scan statistic (Kulldorff 2001). scan_eb_negbin: computes expectation-based negative binomial scan statistic (Tango et al. 2011). scan_eb_zip: computes expectation-based zero-inflated Poisson scan statistic (Allévius & Höhle 2017). scan_permutation: computes space-time permutation scan statistic (Kulldorff et al. 2005). scan_bayes_negbin: computes Bayesian Spatial scan statistic (Neill 2006), extended space-time setting.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"zone-creation","dir":"","previous_headings":"Main functions","what":"Zone creation","title":"Space-Time Anomaly Detection using Scan Statistics","text":"coords_to_knn: use stats::dist get k nearest neighbors location format usable knn_zones. dist_to_knn: use already computed distance matrix get k nearest neighbors location format usable knn_zones. flexible_zones: alternative knn_zones uses adjacency structure locations create richer set zones. additional input adjacency matrix, otherwise works knn_zones.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"miscellaneous","dir":"","previous_headings":"Main functions","what":"Miscellaneous","title":"Space-Time Anomaly Detection using Scan Statistics","text":"score_locations: Score location likely ongoing anomaly . score heuristically motivated. top_clusters: Get top k space-time clusters, either overlapping non-overlapping spatial dimension. df_to_matrix: Convert data frame data location time point matrix locations along column dimension time along row dimension, selected data values.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"example-brain-cancer-in-new-mexico","dir":"","previous_headings":"","what":"Example: Brain cancer in New Mexico","title":"Space-Time Anomaly Detection using Scan Statistics","text":"demonstrate scan statistics package, use dataset annual number brain cancer cases counties New Mexico, years 1973-1991. data studied Kulldorff (1998), detected cluster cancer cases counties Los Alamos Santa Fe years 1986-1989, though excess brain cancer cluster deemed statistically significant. data originally comes package rsatscan, provides interface program SaTScan, aggregated extended scanstatistics package. get familiar counties New Mexico, begin plotting map using data frames NM_map NM_geo supplied scanstatistics package:  can obtain yearly number cases population country years 1973-1991 data table NM_popcas provided package: noted Cibola county split Valencia county 1981, cases Cibola counted Valencia data.","code":"library(scanstatistics) library(ggplot2) #> Registered S3 method overwritten by 'ggplot2': #>   method        from #>   print.element sets  # Load map data data(NM_map) data(NM_geo)  # Plot map with labels at centroids ggplot() +    geom_polygon(data = NM_map,                mapping = aes(x = long, y = lat, group = group),                color = \"grey\", fill = \"white\") +   geom_text(data = NM_geo,              mapping = aes(x = center_long, y = center_lat, label = county)) +   ggtitle(\"Counties of New Mexico\") data(NM_popcas) head(NM_popcas) #>   year     county population count #> 1 1973 bernalillo     353813    16 #> 2 1974 bernalillo     357520    16 #> 3 1975 bernalillo     368166    16 #> 4 1976 bernalillo     378483    16 #> 5 1977 bernalillo     388471    15 #> 6 1978 bernalillo     398130    18"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"a-scan-statistic-for-poisson-data","dir":"","previous_headings":"Example: Brain cancer in New Mexico","what":"A scan statistic for Poisson data","title":"Space-Time Anomaly Detection using Scan Statistics","text":"Poisson distribution natural first option dealing count data. scanstatistics package provides two functions scan_eb_poisson scan_pb_poisson distributional assumption. first expectation-based[1] scan statistic univariate Poisson-distributed data proposed Neill et al. (2005), focus one example . second scan statistic population-based scan statistic proposed Kulldorff (2001).","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"using-the-poisson-scan-statistic","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Using the Poisson scan statistic","title":"Space-Time Anomaly Detection using Scan Statistics","text":"first argument scan statistics package matrix (array) observed counts, whether integer counts real-valued “counts”. matrix, columns represent locations rows time intervals, ordered chronologically earliest interval first row recent last. example like detect potential cluster brain cancer counties New Mexico years 1986-1989, begin retrieving count population data period reshaping matrix using helper function df_to_matrix:","code":"library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union counts <- NM_popcas %>%    filter(year >= 1986 & year < 1990) %>%   df_to_matrix(time_col = \"year\", location_col = \"county\", value_col = \"count\")"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"spatial-zones","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Spatial zones","title":"Space-Time Anomaly Detection using Scan Statistics","text":"second argument scan_eb_poisson list integer vectors, vector zone, name spatial component potential outbreak cluster. zone consists one locations grouped together according similarity across features, location numbered corresponding column index counts matrix (indexing starts 1). example, locations counties New Mexico features coordinates county seats. made available data table NM_geo. Similarity measured using geographical distance seats counties, taking account curvature earth. distance matrix calculated using spDists function sp package, passed dist_to_knn knn_zones:","code":"library(sp) library(magrittr)  # Remove Cibola since cases have been counted towards Valencia. Ideally, this # should be accounted for when creating the zones. zones <- NM_geo %>%   filter(county != \"cibola\") %>%   select(seat_long, seat_lat) %>%   as.matrix %>%   spDists(x = ., y = ., longlat = TRUE) %>%   dist_to_knn(k = 15) %>%   knn_zones"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"baselines","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Baselines","title":"Space-Time Anomaly Detection using Scan Statistics","text":"advantage expectation-based scan statistics parameters expected value can modelled estimated past data e.g. form regression. expectation-based Poisson scan statistic, can use (simple) Poisson GLM estimate expected value count county year, accounting different populations region. Similar counts argument, expected values passed matrix scan_eb_poisson function: Note population numbers (perhaps poorly) interpolated censuses conducted 1973, 1982, 1991.","code":"mod <- glm(count ~ offset(log(population)) + 1 + I(year - 1985),            family = poisson(link = \"log\"),            data = NM_popcas %>% filter(year < 1986))  ebp_baselines <- NM_popcas %>%    filter(year >= 1986 & year < 1990) %>%   mutate(mu = predict(mod, newdata = ., type = \"response\")) %>%   df_to_matrix(value_col = \"mu\")"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"calculation","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Calculation","title":"Space-Time Anomaly Detection using Scan Statistics","text":"can now calculate Poisson scan statistic. give us confidence detection results, perform 999 Monte Carlo replications, data generated using parameters null hypothesis new scan statistic calculated. summarized P-value, calculated proportion times replicated scan statistics exceeded observed one. output scan_poisson object class “scanstatistic”, comes print method seen . can see, likely cluster anomaly stretches 1986-1989 involves locations numbered 15 26, correspond counties counties detected Kulldorff (1998), though analysis retrospective rather prospective . also data dredging used study period hopes detecting cluster.","code":"set.seed(1) poisson_result <- scan_eb_poisson(counts = counts,                                    zones = zones,                                    baselines = ebp_baselines,                                   n_mcsim = 999) print(poisson_result) #> Data distribution:                Poisson #> Type of scan statistic:           expectation-based #> Setting:                          univariate #> Number of locations considered:   32 #> Maximum duration considered:      4 #> Number of spatial zones:          415 #> Number of Monte Carlo replicates: 999 #> Monte Carlo P-value:              0.005 #> Gumbel P-value:                   NULL #> Most likely event duration:       4 #> ID of locations in MLC:           15, 26 counties <- as.character(NM_geo$county) counties[c(15, 26)] [1] \"losalamos\" \"santafe\""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"a-heuristic-score-for-locations","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"A heuristic score for locations","title":"Space-Time Anomaly Detection using Scan Statistics","text":"can score county according likely part cluster heuristic fashion using function score_locations, visualize results heatmap follows:  warning though: score_locations function can quite slow large data sets. might change future versions package.","code":"# Calculate scores and add column with county names county_scores <- score_locations(poisson_result, zones) county_scores %<>% mutate(county = factor(counties[-length(counties)],                                            levels = levels(NM_geo$county)))  # Create a table for plotting score_map_df <- merge(NM_map, county_scores, by = \"county\", all.x = TRUE) %>%   arrange(group, order)  # As noted before, Cibola county counts have been attributed to Valencia county score_map_df[score_map_df$subregion == \"cibola\", ] %<>%   mutate(relative_score = score_map_df %>%                            filter(subregion == \"valencia\") %>%                            select(relative_score) %>%                            .[[1]] %>% .[1])  ggplot() +    geom_polygon(data = score_map_df,                mapping = aes(x = long, y = lat, group = group,                               fill = relative_score),                color = \"grey\") +   scale_fill_gradient(low = \"#e5f5f9\", high = \"darkgreen\",                       guide = guide_colorbar(title = \"Relative\\nScore\")) +   geom_text(data = NM_geo,              mapping = aes(x = center_long, y = center_lat, label = county),             alpha = 0.5) +   ggtitle(\"County scores\")"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"finding-the-top-scoring-clusters","dir":"","previous_headings":"Example: Brain cancer in New Mexico > A scan statistic for Poisson data","what":"Finding the top-scoring clusters","title":"Space-Time Anomaly Detection using Scan Statistics","text":"Finally, want know just likely cluster, say five top-scoring space-time clusters, can use function top_clusters. clusters returned can either overlapping non-overlapping spatial dimension, according liking. top_clusters function includes Monte Carlo Gumbel P-values cluster. P-values conservative, since secondary clusters original data compared likely clusters replicate data sets.","code":"top5 <- top_clusters(poisson_result, zones, k = 5, overlapping = FALSE)  # Find the counties corresponding to the spatial zones of the 5 clusters. top5_counties <- top5$zone %>%   purrr::map(get_zone, zones = zones) %>%   purrr::map(function(x) counties[x])  # Add the counties corresponding to the zones as a column top5 %<>% mutate(counties = top5_counties)"},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"concluding-remarks","dir":"","previous_headings":"","what":"Concluding remarks","title":"Space-Time Anomaly Detection using Scan Statistics","text":"univariate scan statistics can calculated practically way , though distribution parameters need adapted scan statistic.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"feedback","dir":"","previous_headings":"","what":"Feedback","title":"Space-Time Anomaly Detection using Scan Statistics","text":"think package lacks functionality, something needs better documentation, please open issue . ’m also interested applying methods package (current future) new problems, know suitable public datasets, please tell ! dataset multivariate response (e.g. multiple counter variables) particular interest.","code":""},{"path":"https://promerpr.github.io/scanstatistics/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Space-Time Anomaly Detection using Scan Statistics","text":"Allévius, B., M. Höhle (2017): expectation-based space-time scan statistic ZIP-distributed data, (review). Kleinman, K. (2015): Rsatscan: Tools, Classes, Methods Interfacing SaTScan Stand-Alone Software, https://CRAN.R-project.org/package=rsatscan. Kulldorff, M., Athas, W. F., Feuer, E. J., Miller, B. ., Key, C. R. (1998): Evaluating Cluster Alarms: Space-Time Scan Statistic Brain Cancer Los Alamos, American Journal Public Health 88 (9), 1377–80. Kulldorff, M. (2001), Prospective time periodic geographical disease surveillance using scan statistic, Journal Royal Statistical Society, Series (Statistics Society), 164, 61–72. Kulldorff, M., Heffernan, R., Hartman, J., Assunção, R. M., Mostashari, F. (2005): space-time permutation scan statistic disease outbreak detection, PLoS Medicine, 2 (3), 0216-0224. Neill, D. B., Moore, . W., Sabhnani, M., Daniel, K. (2005): Detection Emerging Space-Time Clusters, Proceedings Eleventh ACM SIGKDD International Conference Knowledge Discovery Data Mining, 218–27. ACM. Neill, D. B., Moore, . W., Cooper, G. F. (2006): Bayesian Spatial Scan Statistic, Advances Neural Information Processing Systems 18: Proceedings 2005 Conference. Tango, T., Takahashi, K. Kohriyama, K. (2011), Space-Time Scan Statistic Detecting Emerging Outbreaks, Biometrics 67 (1), 106–15. [1] Expectation-based scan statistics use past non-anomalous data estimate distribution parameters, compares observed cluster counts time period interest estimates. contrast, population-based scan statistics compare counts cluster outside, using data period interest, conditional observed total count.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/closest_subsets.html","id":null,"dir":"Reference","previous_headings":"","what":"Set of increasing sets from left to right of input vector. — closest_subsets","title":"Set of increasing sets from left to right of input vector. — closest_subsets","text":"Returns set (list) increasing sets (integer vectors) input  vector v, sense first set contains first element  v, second set first second elements v,  .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/closest_subsets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set of increasing sets from left to right of input vector. — closest_subsets","text":"","code":"closest_subsets(v)"},{"path":"https://promerpr.github.io/scanstatistics/reference/closest_subsets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set of increasing sets from left to right of input vector. — closest_subsets","text":"v integer vector. Meant represent \\(k\\) nearest neighbors location, first element integer identifier  location .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/closest_subsets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set of increasing sets from left to right of input vector. — closest_subsets","text":"list length input. first element list    v[1], second sort(v[1:2]), third sort(v[1:3]), .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_neighbors.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the connected sets for a location and its \\(k\\) nearest neighbors. — connected_neighbors","title":"Find the connected sets for a location and its \\(k\\) nearest neighbors. — connected_neighbors","text":"Returns set sets, set latter type containing location zero neighbors, connected.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_neighbors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the connected sets for a location and its \\(k\\) nearest neighbors. — connected_neighbors","text":"","code":"connected_neighbors(neighbors, adjacency_matrix)"},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_neighbors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the connected sets for a location and its \\(k\\) nearest neighbors. — connected_neighbors","text":"neighbors vector neighbors location, first element vector specific location, elements  nearest neighbors. Locations encoded integers. adjacency_matrix boolean matrix, element \\((,j)\\) set  TRUE location \\(j\\) adjacent location \\(\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_neighbors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the connected sets for a location and its \\(k\\) nearest neighbors. — connected_neighbors","text":"Returns set sets, set latter type     containing location zero neighbors,     connected.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_to.html","id":null,"dir":"Reference","previous_headings":"","what":"Return those elements in the second set which are connected to those in the\r\nfirst. — connected_to","title":"Return those elements in the second set which are connected to those in the\r\nfirst. — connected_to","text":"Return elements second set \\(Z_1\\) connected  first set \\(Z_0\\), according adjacency matrix.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_to.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return those elements in the second set which are connected to those in the\r\nfirst. — connected_to","text":"","code":"connected_to(Z_0, Z_1, adjacency_matrix)"},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_to.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return those elements in the second set which are connected to those in the\r\nfirst. — connected_to","text":"Z_0 set locations, given integers. Z_1 set locations, given integers. adjacency_matrix boolean matrix, element \\((,j)\\) set  TRUE location \\(j\\) adjacent location \\(\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/connected_to.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return those elements in the second set which are connected to those in the\r\nfirst. — connected_to","text":"set, possibly empty, containing locations \\(Z_1\\)        connected locations \\(Z_0\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/coords_to_knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","title":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","text":"Get k nearest neighbors location, including location . function calls dist, options  distance measure used one. Distances calculated  rows.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/coords_to_knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","text":"","code":"coords_to_knn(x, k = min(10, nrow(x)), method = \"euclidean\", p = 2)"},{"path":"https://promerpr.github.io/scanstatistics/reference/coords_to_knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","text":"x numeric matrix, data frame \"dist\" object. k number nearest neighbors, counting location . method distance measure used.  must one     \"euclidean\", \"maximum\", \"manhattan\",     \"canberra\", \"binary\" \"minkowski\".     unambiguous substring can given. p power Minkowski distance.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/coords_to_knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","text":"integer matrix \\(k\\) nearest neighbors location.     row corresponds location, first element row     location . Locations encoded integers.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/coords_to_knn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the k nearest neighbors for each location, given its coordinates. — coords_to_knn","text":"","code":"x <- matrix(c(0, 0,               1, 0,               2, 1,               0, 4,               1, 3),             ncol = 2, byrow = TRUE) plot(x)  coords_to_knn(x) #>   [,1] [,2] [,3] [,4] [,5] #> 1    1    2    3    5    4 #> 2    2    1    3    5    4 #> 3    3    2    1    5    4 #> 4    4    5    3    1    2 #> 5    5    4    3    2    1"},{"path":"https://promerpr.github.io/scanstatistics/reference/df_to_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a long data frame to a wide matrix. — df_to_matrix","title":"Convert a long data frame to a wide matrix. — df_to_matrix","text":"Convert long data frame wide matrix, time along row dimension locations along column dimension. Values matrix e.g. observed counts population.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/df_to_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a long data frame to a wide matrix. — df_to_matrix","text":"","code":"df_to_matrix(df, time_col = 1, location_col = 2, value_col = 3)"},{"path":"https://promerpr.github.io/scanstatistics/reference/df_to_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a long data frame to a wide matrix. — df_to_matrix","text":"df data frame least 3 columns. time_col Integer string specifies time column. location_col Integer string specifies location column. value_col Integer string specifies value column.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/df_to_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a long data frame to a wide matrix. — df_to_matrix","text":"matrix time rows locations columns.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/dist_to_knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","title":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","text":"Given distance matrix, calculate \\(k\\) nearest neighbors  location, including location . matrix contain zeros  diagonal, elements positive.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/dist_to_knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","text":"","code":"dist_to_knn(x, k = min(10, nrow(x)))"},{"path":"https://promerpr.github.io/scanstatistics/reference/dist_to_knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","text":"x (square) distance matrix. Elements non-negative  diagonal zeros, checked. k number nearest neighbors, counting location .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/dist_to_knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","text":"matrix integers, row \\(\\) containing \\(k\\) nearest     neighbors location \\(\\), including .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/dist_to_knn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Given a distance matrix, find the \\(k\\) nearest neighbors. — dist_to_knn","text":"","code":"x <- matrix(c(0, 0,               1, 0,               2, 1,               0, 4,               1, 3),             ncol = 2, byrow = TRUE) d <- dist(x, diag = TRUE, upper = TRUE) dist_to_knn(d, k = 3) #>   [,1] [,2] [,3] #> 1    1    2    3 #> 2    2    1    3 #> 3    3    2    1 #> 4    4    5    3 #> 5    5    4    3"},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_baselines.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate baselines based on observed counts. — estimate_baselines","title":"Estimate baselines based on observed counts. — estimate_baselines","text":"Estimate baselines (expected values) supplied counts.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_baselines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate baselines based on observed counts. — estimate_baselines","text":"","code":"estimate_baselines(counts, population = NULL)"},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_baselines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate baselines based on observed counts. — estimate_baselines","text":"counts matrix observed counts. Rows indicate time (ordered  recent) columns indicate locations. population matrix vector populations location  (optional). matrix, dimensions  counts. vector, length number columns counts.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_baselines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate baselines based on observed counts. — estimate_baselines","text":"matrix baselines dimensions counts.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_variances.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate variances based on observed counts. — estimate_variances","title":"Estimate variances based on observed counts. — estimate_variances","text":"Estimate variances supplied counts. assumed variances constant time location.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_variances.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate variances based on observed counts. — estimate_variances","text":"","code":"estimate_variances(   counts,   baselines = NULL,   population = NULL,   constant_dim = 1 )"},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_variances.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate variances based on observed counts. — estimate_variances","text":"counts matrix observed counts. Rows indicate time (ordered  recent) columns indicate locations. baselines matrix dimensions counts (optional). population matrix vector populations location  (optional). matrix, dimensions  counts. vector, length number columns counts. constant_dim integer. equal 1, variances assumed constant time different locations. equal 2,  variances assumed vary time time point equal  locations.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_variances.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate variances based on observed counts. — estimate_variances","text":"matrix variances dimensions counts.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_zip_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the parameters of a ZIP distribution. — estimate_zip_params","title":"Estimate the parameters of a ZIP distribution. — estimate_zip_params","text":"Heuristically estimate ZIP distribution Poisson mean parameters  structural zero probabilities location time point. Assumes  structural zero probability constant time location.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_zip_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the parameters of a ZIP distribution. — estimate_zip_params","text":"","code":"estimate_zip_params(counts, population = NULL, min_p = 0.001, min_mu = 0.3)"},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_zip_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the parameters of a ZIP distribution. — estimate_zip_params","text":"counts matrix vector observed counts. Rows indicate time  (ordered recent) columns indicate locations. vector, elements assumed counts location. population matrix vector populations location  (optional). matrix, dimensions  counts. vector, length number columns counts. min_p minimum value think possible structural zero probability. min_mu mimum value think possible Poisson mean  parameter ZIP distribution (adjusting population size).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/estimate_zip_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the parameters of a ZIP distribution. — estimate_zip_params","text":"list two elements: baselines matrix dimensions counts.                       counts vector, matrix 1 row                       returned. probs matrix dimensions counts.                    counts vector, matrix 1 row                   returned.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":null,"dir":"Reference","previous_headings":"","what":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"Given matrix \\(k\\) nearest neighbors adjacency matrix locations involved, produces set flexibly shaped zones list integer vectors. locations zones connected,  sense location zone can reached another  traveling adjacent locations within zone.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"","code":"flexible_zones(k_nearest, adjacency_matrix)"},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"k_nearest integer matrix \\(k\\) nearest neighbors  location. row corresponds location, first element  row location . Locations encoded  integers. adjacency_matrix boolean matrix, element \\((,j)\\) set  TRUE location \\(j\\) adjacent location \\(\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"list integer vectors.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"Tango, T. & Takahashi, K. (2005), flexibly shaped spatial scan     statistic detecting clusters, International Journal Health     Geographics 4(1).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flexible_zones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Computes the flexibly shaped zones as in Tango (2005). — flexible_zones","text":"","code":"A <- matrix(c(0,1,0,0,0,0,               1,0,1,0,0,0,               0,1,0,0,0,0,               0,0,0,0,1,0,               0,0,0,1,0,0,               0,0,0,0,0,0),                nrow = 6, byrow = TRUE) == 1 nn <- matrix(as.integer(c(1,2,3,4,5,6,                           2,1,3,4,5,6,                           3,2,1,4,5,6,                           4,5,1,6,3,2,                           5,4,6,1,3,2,                           6,5,4,1,3,2)),                           nrow = 6, byrow = TRUE) flexible_zones(nn, A) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 3 #>  #> [[4]] #> [1] 2 #>  #> [[5]] #> [1] 2 3 #>  #> [[6]] #> [1] 3 #>  #> [[7]] #> [1] 4 #>  #> [[8]] #> [1] 4 5 #>  #> [[9]] #> [1] 5 #>  #> [[10]] #> [1] 6 #>"},{"path":"https://promerpr.github.io/scanstatistics/reference/flipud.html","id":null,"dir":"Reference","previous_headings":"","what":"Flip a matrix upside down — flipud","title":"Flip a matrix upside down — flipud","text":"Flip matrix upside ","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flipud.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flip a matrix upside down — flipud","text":"","code":"flipud(x)"},{"path":"https://promerpr.github.io/scanstatistics/reference/flipud.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flip a matrix upside down — flipud","text":"x matrix","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/flipud.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flip a matrix upside down — flipud","text":"matrix, x rows reversed.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zero_indices.html","id":null,"dir":"Reference","previous_headings":"","what":"Get indices of zero elements in a vector. — get_zero_indices","title":"Get indices of zero elements in a vector. — get_zero_indices","text":"Get indices zero elements vector.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zero_indices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get indices of zero elements in a vector. — get_zero_indices","text":"","code":"get_zero_indices(v)"},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zero_indices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get indices of zero elements in a vector. — get_zero_indices","text":"v integer vector.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zero_indices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get indices of zero elements in a vector. — get_zero_indices","text":"vector indices elements equal zero v.    Indices start zero.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zone.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a zone from the set of all zones. — get_zone","title":"Extract a zone from the set of all zones. — get_zone","text":"Extract zone number \\(n\\) set zones.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a zone from the set of all zones. — get_zone","text":"","code":"get_zone(n, zones)"},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zone.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a zone from the set of all zones. — get_zone","text":"n integer; number zone wish retrieve. zones list integer vectors, representing set zones.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zone.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a zone from the set of all zones. — get_zone","text":"integer vector.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/get_zone.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a zone from the set of all zones. — get_zone","text":"","code":"zones <- list(1L, 2L, 3L, 1:2, c(1L, 3L), c(2L, 3L)) get_zone(4, zones) #> [1] 1 2"},{"path":"https://promerpr.github.io/scanstatistics/reference/gumbel_pvalue.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Gumbel \\(p\\)-value for a scan statistic. — gumbel_pvalue","title":"Calculate the Gumbel \\(p\\)-value for a scan statistic. — gumbel_pvalue","text":"Given observed scan statistic \\(\\lambda^*\\) vector replicate  scan statistics \\(\\lambda_i\\), \\(=1,\\ldots,R\\), fit Gumbel  distribution replicates calculate \\(p\\)-value observed statistic based fitted distribution. $$  \\frac{1 + \\sum_{=1}^R \\mathrm{}(\\lambda_i > \\lambda^*)}{1 + R} $$ function vectorized, multiple \\(p\\)-values can calculated several scan statistics (e.g. statistics secondary clusters)  supplied.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/gumbel_pvalue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Gumbel \\(p\\)-value for a scan statistic. — gumbel_pvalue","text":"","code":"gumbel_pvalue(observed, replicates, method = \"ML\", ...)"},{"path":"https://promerpr.github.io/scanstatistics/reference/gumbel_pvalue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Gumbel \\(p\\)-value for a scan statistic. — gumbel_pvalue","text":"observed scalar containing observed value scan statistic, vector observed values secondary clusters. replicates vector Monte Carlo replicates scan statistic. method Either \"ML\", maximum likelihood, \"MoM\", method  moments. ... Additional arguments passed ismev::gum.fit,  may include arguments passed along optim.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/gumbel_pvalue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Gumbel \\(p\\)-value for a scan statistic. — gumbel_pvalue","text":"\\(p\\)-value \\(p\\)-values corresponding observed     scan statistic(s).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/has_converged.html","id":null,"dir":"Reference","previous_headings":"","what":"Is the relative error between two numbers is less than the given tolerance? — has_converged","title":"Is the relative error between two numbers is less than the given tolerance? — has_converged","text":"Given two consecutive numbers sequence, return TRUE relative change positive less given tolerance.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/has_converged.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is the relative error between two numbers is less than the given tolerance? — has_converged","text":"","code":"has_converged(current, previous, tol = 0.01)"},{"path":"https://promerpr.github.io/scanstatistics/reference/has_converged.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is the relative error between two numbers is less than the given tolerance? — has_converged","text":"current scalar; recent value sequence. previous scalar; second recent value sequence, reference value. tol tolerance, positive scalar near zero.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/if_connected.html","id":null,"dir":"Reference","previous_headings":"","what":"Return a set of the location and its neighbors if they are connected,\r\nelse return the empty set. — if_connected","title":"Return a set of the location and its neighbors if they are connected,\r\nelse return the empty set. — if_connected","text":"location neighbors, including , connected, return set containing location neighbors; otherwise, return empty set","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/if_connected.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return a set of the location and its neighbors if they are connected,\r\nelse return the empty set. — if_connected","text":"","code":"if_connected(distinct_neighbors, location, adjacency_matrix)"},{"path":"https://promerpr.github.io/scanstatistics/reference/if_connected.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return a set of the location and its neighbors if they are connected,\r\nelse return the empty set. — if_connected","text":"distinct_neighbors set containing neighboring locations given location, including location . location location, preferably given integer. adjacency_matrix boolean matrix, element \\((,j)\\) set  TRUE location \\(j\\) adjacent location \\(\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/if_connected.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return a set of the location and its neighbors if they are connected,\r\nelse return the empty set. — if_connected","text":"set given location neighbors    connected, else returns empty set.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/is_connected.html","id":null,"dir":"Reference","previous_headings":"","what":"Returns TRUE if the neighboring locations are connected to the given \r\nlocation, FALSE if not. — is_connected","title":"Returns TRUE if the neighboring locations are connected to the given \r\nlocation, FALSE if not. — is_connected","text":"Returns TRUE neighboring locations connected given  location, FALSE .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/is_connected.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Returns TRUE if the neighboring locations are connected to the given \r\nlocation, FALSE if not. — is_connected","text":"","code":"is_connected(neighbor_locations, location, adjacency_matrix)"},{"path":"https://promerpr.github.io/scanstatistics/reference/is_connected.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Returns TRUE if the neighboring locations are connected to the given \r\nlocation, FALSE if not. — is_connected","text":"neighbor_locations set neighboring locations given location; neighbors include given location . location location, preferably given integer. adjacency_matrix boolean matrix, element \\((,j)\\) set  TRUE location \\(j\\) adjacent location \\(\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/is_connected.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Returns TRUE if the neighboring locations are connected to the given \r\nlocation, FALSE if not. — is_connected","text":"Boolean: neighbors connected given location?","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/knn_zones.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","title":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","text":"Returns set increasing nearest neighbor sets locations, list integer vectors. , location list returned  contains one vector containing location , another containing  location nearest neighbor, , vector containing  location \\(k-1\\) nearest neighbors.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/knn_zones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","text":"","code":"knn_zones(k_nearest)"},{"path":"https://promerpr.github.io/scanstatistics/reference/knn_zones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","text":"k_nearest integer matrix \\(k\\) columns many rows locations. first element row integer encoding location (equal row number); following elements  \\(k-1\\) nearest neighbors ascending order distance.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/knn_zones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","text":"list integer vectors.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/knn_zones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the increasing subsets of \\(k\\) nearest neighbors for all locations. — knn_zones","text":"","code":"nn <- matrix(c(1L, 2L, 4L, 3L, 5L,                2L, 1L, 3L, 4L, 5L,                 3L, 2L, 4L, 1L, 5L,                4L, 1L, 2L, 3L, 5L,                5L, 3L, 4L, 2L, 1L),                ncol = 5, byrow = TRUE) knn_zones(nn[, 1:3]) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 1 2 #>  #> [[3]] #> [1] 1 2 4 #>  #> [[4]] #> [1] 2 #>  #> [[5]] #> [1] 1 2 3 #>  #> [[6]] #> [1] 3 #>  #> [[7]] #> [1] 2 3 #>  #> [[8]] #> [1] 2 3 4 #>  #> [[9]] #> [1] 4 #>  #> [[10]] #> [1] 1 4 #>  #> [[11]] #> [1] 5 #>  #> [[12]] #> [1] 3 5 #>  #> [[13]] #> [1] 3 4 5 #>"},{"path":"https://promerpr.github.io/scanstatistics/reference/matrix_to_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a matrix to a data frame. — matrix_to_df","title":"Convert a matrix to a data frame. — matrix_to_df","text":"Convert matrix data frame columns time, location, one containing elements input matrix.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/matrix_to_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a matrix to a data frame. — matrix_to_df","text":"","code":"matrix_to_df(mat, name, locations = NULL, times = NULL)"},{"path":"https://promerpr.github.io/scanstatistics/reference/matrix_to_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a matrix to a data frame. — matrix_to_df","text":"mat matrix. name name third column output matrix. locations NULL, vector names  locations. times NULL, vector time points.  NULL, matrix assumed ordered time point 1  first row.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/matrix_to_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a matrix to a data frame. — matrix_to_df","text":"matrix columns time, location, name, name   specified input.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/mc_pvalue.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Monte Carlo \\(p\\)-value for a scan statistic. — mc_pvalue","title":"Calculate the Monte Carlo \\(p\\)-value for a scan statistic. — mc_pvalue","text":"Given observed scan statistic \\(\\lambda^*\\) vector replicate  scan statistics \\(\\lambda_i\\), \\(=1,\\ldots,R\\), calculate Monte  Carlo \\(p\\)-value $$  \\frac{1 + \\sum_{=1}^R \\mathrm{}(\\lambda_i > \\lambda^*)}{1 + R} $$ function vectorized, multiple \\(p\\)-values can calculated several scan statistics (e.g. statistics secondary clusters)  supplied.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/mc_pvalue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Monte Carlo \\(p\\)-value for a scan statistic. — mc_pvalue","text":"","code":"mc_pvalue(observed, replicates)"},{"path":"https://promerpr.github.io/scanstatistics/reference/mc_pvalue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Monte Carlo \\(p\\)-value for a scan statistic. — mc_pvalue","text":"observed scalar containing observed value scan statistic, vector observed values secondary clusters. replicates vector Monte Carlo replicates scan statistic.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/mc_pvalue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the Monte Carlo \\(p\\)-value for a scan statistic. — mc_pvalue","text":"\\(p\\)-value \\(p\\)-values corresponding observed     scan statistic(s).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_geo.html","id":null,"dir":"Reference","previous_headings":"","what":"Longitude and latitude of New Mexico county seats. — NM_geo","title":"Longitude and latitude of New Mexico county seats. — NM_geo","text":"dataset containing longitude latitude county seats New Mexico, except Cibola county.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_geo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Longitude and latitude of New Mexico county seats. — NM_geo","text":"","code":"NM_geo"},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_geo.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Longitude and latitude of New Mexico county seats. — NM_geo","text":"data frame 33 rows 7 variables: county Factor; counties New Mexico (spaces). seat Character; name county seat, .e. administrative                center seat government. area(km2) Numeric; area square kilometers county. seat_long Numeric; longitude county seat. seat_lat Numeric; latitude county seat. center_long Numeric; longitude geographical center                      county. center_lat Numeric; latitude geographical center                      county.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_geo.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Longitude and latitude of New Mexico county seats. — NM_geo","text":"https://en.wikipedia.org/wiki/List_of_counties_in_New_Mexico","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Data to plot the counties of New Mexico. — NM_map","title":"Data to plot the counties of New Mexico. — NM_map","text":"Map data New Mexico. created using ggplot2::map_data.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data to plot the counties of New Mexico. — NM_map","text":"","code":"NM_map"},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_map.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data to plot the counties of New Mexico. — NM_map","text":"data frame 867 rows 7 variables: long Numeric; longitude county polygon corner. lat Numeric; latitude county polygon corner. group Numeric; grouping county. order Numeric; order polygon corners. region Character; region \"new mexico\" rows. subregion Character; county name (spaces). county Factor; county name (spaces).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_popcas.html","id":null,"dir":"Reference","previous_headings":"","what":"Population and brain cancer cases in New Mexico counties during 1973--1991. — NM_popcas","title":"Population and brain cancer cases in New Mexico counties during 1973--1991. — NM_popcas","text":"dataset containing population count number brain cancer cases  counties New Mexico years 1973--1991. population  numbers interpolations censuses conducted 1973, 1982,  1991. Interpolations done using quadratic function time. Thus year--year changes overly smooth match census numbers  three years mentioned.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_popcas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Population and brain cancer cases in New Mexico counties during 1973--1991. — NM_popcas","text":"","code":"NM_popcas"},{"path":"https://promerpr.github.io/scanstatistics/reference/NM_popcas.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Population and brain cancer cases in New Mexico counties during 1973--1991. — NM_popcas","text":"data frame 608 rows 4 variables: year Integer; year cases recorded. county Character; name county (spaces). population Integer; population county year. count Integer; number brain cancer cases county                 year.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/permute_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Permute the entries of the matrix, preserving row and column marginals. — permute_matrix","title":"Permute the entries of the matrix, preserving row and column marginals. — permute_matrix","text":"Permute entries matrix, preserving row column marginals.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/permute_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permute the entries of the matrix, preserving row and column marginals. — permute_matrix","text":"","code":"permute_matrix(A)"},{"path":"https://promerpr.github.io/scanstatistics/reference/permute_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permute the entries of the matrix, preserving row and column marginals. — permute_matrix","text":"integer matrix.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/permute_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permute the entries of the matrix, preserving row and column marginals. — permute_matrix","text":"integer matrix.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/powerset_zones.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a set of all non-empty subsets of the integers from 1 to \\(n\\). — powerset_zones","title":"Creates a set of all non-empty subsets of the integers from 1 to \\(n\\). — powerset_zones","text":"Creates list \\(2^(n-1)\\) non-empty subsets integers 1  \\(n\\).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/powerset_zones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a set of all non-empty subsets of the integers from 1 to \\(n\\). — powerset_zones","text":"","code":"powerset_zones(n)"},{"path":"https://promerpr.github.io/scanstatistics/reference/powerset_zones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a set of all non-empty subsets of the integers from 1 to \\(n\\). — powerset_zones","text":"n integer larger 0.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/powerset_zones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a set of all non-empty subsets of the integers from 1 to \\(n\\). — powerset_zones","text":"list integer vectors.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/print.scanstatistic.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a scanstatistic object. — print.scanstatistic","title":"Print a scanstatistic object. — print.scanstatistic","text":"Prints scanstatistic object returns invisibly.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/print.scanstatistic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a scanstatistic object. — print.scanstatistic","text":"","code":"# S3 method for scanstatistic print(x, ...)"},{"path":"https://promerpr.github.io/scanstatistics/reference/print.scanstatistic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a scanstatistic object. — print.scanstatistic","text":"x object class scanstatistic. ... arguments passed methods.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/run_scan.html","id":null,"dir":"Reference","previous_headings":"","what":"Run a scan statistic analysis. — run_scan","title":"Run a scan statistic analysis. — run_scan","text":"Run scan statistic analysis given scan statistic arguments.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/run_scan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run a scan statistic analysis. — run_scan","text":"","code":"run_scan(scanstat, args, gumbel = FALSE)"},{"path":"https://promerpr.github.io/scanstatistics/reference/run_scan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run a scan statistic analysis. — run_scan","text":"scanstat scan statistic function. args named list arguments passed scanstat. gumbel Logical: Gumbel P-value calculated? Default FALSE.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/run_scan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run a scan statistic analysis. — run_scan","text":"list components observed table observed statistics. simulated table simulated statistics. MC_pvalue Monte Carlo P-value scan statistic. Gumbel_pvalue Gumbel P-value scan statistic.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scanstatistics.html","id":null,"dir":"Reference","previous_headings":"","what":"scanstatistics: Space-time anomaly detection using scan statistics. — scanstatistics","title":"scanstatistics: Space-time anomaly detection using scan statistics. — scanstatistics","text":"scanstatistics package provides two categories important functions: data preparation functions, scan statistics .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scanstatistics.html","id":"data-preparation-functions","dir":"Reference","previous_headings":"","what":"Data preparation functions","title":"scanstatistics: Space-time anomaly detection using scan statistics. — scanstatistics","text":"functions prepare data use. particular, helps  define zones considered scan statistics.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scanstatistics.html","id":"scan-statistics","dir":"Reference","previous_headings":"","what":"Scan statistics","title":"scanstatistics: Space-time anomaly detection using scan statistics. — scanstatistics","text":"functions used space-time anomaly detection. Scan statistic functions univariate space-time data name begins  scan_ functions multivariate space-time data name begins mscan_.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"Calculate \"Bayesian Spatial Scan Statistic\" Neill et al. (2006), adapted spatio-temporal setting. scan statistic assumes , given relative risk, data follows Poisson distribution.  relative risk turn assigned Gamma distribution prior, yielding  negative binomial marginal distribution counts null  hypothesis. alternative hypothesis, ","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"","code":"scan_bayes_negbin(   counts,   zones,   baselines = NULL,   population = NULL,   outbreak_prob = 0.05,   alpha_null = 1,   beta_null = 1,   alpha_alt = alpha_null,   beta_alt = beta_null,   inc_values = seq(1, 3, by = 0.1),   inc_probs = 1 )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional matrix argument         baselines also specified. data frame columns \"time\", \"location\", \"count\", \"baseline\".         Alternatively, column \"baseline\" can replaced column         \"population\". baselines expected values counts. zones list integer vectors. vector corresponds single zone; elements numbers locations zone. baselines Optional. matrix dimensions counts.  needed counts data frame. Holds Poisson mean  parameter observed count. estimated supplied  (requires population argument). parameters typically  estimated past data using e.g. Poisson (GLM) regression. population Optional. matrix vector populations  location. needed counts data frame. counts matrix, population needed baselines  estimated want account different populations  location (time). matrix, dimensions  counts. vector, length number  columns counts. outbreak_prob scalar; probability outbreak (time, place). Defaults 0.05. alpha_null scalar; shape parameter gamma distribution null hypothesis anomaly. Defaults 1. beta_null scalar; scale parameter gamma distribution null hypothesis anomaly. Defaults 1. alpha_alt scalar; shape parameter gamma distribution alternative hypothesis anomaly. Defaults value alpha_null. beta_alt scalar; scale parameter gamma distribution alternative hypothesis anomaly. Defaults value beta_null. inc_values vector possible values increase mean (variance) anomalous count. Defaults evenly spaced values  1 3, difference 0.1 consecutive values. inc_probs vector prior probabilities value  inc_values. Defaults 1, implying discrete uniform  distribution.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"list , addition information type scan    statistic, following components: priors (list),  posteriors (list), MLC (list) marginal_data_prob   (scalar). list MLC elements zone number spatial zone likely cluster                   (MLC). duration likely event duration. log_posterior posterior log probability event                            ongoing MLC. log_bayes_factor logarithm Bayes factor MLC. posterior posterior probability event ongoing                        MLC. locations locations involved MLC. list priors elements null_prior prior probability anomaly. alt_prior prior probability anomaly. inc_prior vectorof prior probabilities value                        argument inc_values. window_prior prior probability outbreak                          space-time windows. list posteriors elements null_posterior posterior probability anomaly. alt_posterior posterior probability anomaly. inc_posterior data frame columns inc_values                           inc_posterior. window_posteriors data frame columns zone,                                duration, log_posterior                                log_bayes_factor, row corresponding                               space-time window. space_time_posteriors matrix posterior anomaly                                    probability location-time                                    combination. location_posteriors vector posterior probability                                 anomaly location.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"Neill, D. B., Moore, . W., Cooper, G. F. (2006).     Bayesian Spatial Scan Statistic. Advances Neural Information     Processing Systems 18.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the negative binomial bayesian scan statistic.. — scan_bayes_negbin","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data baselines <- matrix(rexp(n_total, 1/5), max_duration, n_locs) counts <- matrix(rpois(n_total, as.vector(baselines)), max_duration, n_locs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- matrix(   rpois(ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols]),    length(ob_rows), length(ob_cols)) res <- scan_bayes_negbin(counts = counts,                          zones = zones,                          baselines = baselines) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the ","title":"Calculate the ","text":"Calculate \"Bayesian Spatial Scan Statistic\" Neill et al. (2006), adapted spatio-temporal setting. scan statistic assumes , given relative risk, data follows Poisson distribution.  relative risk turn assigned Gamma distribution prior, yielding  negative binomial marginal distribution counts.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the ","text":"","code":"scan_bayes_negbin_cpp(   counts,   baselines,   zones,   zone_lengths,   outbreak_prob,   alpha_null,   beta_null,   alpha_alt,   beta_alt,   inc_values,   inc_probs )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the ","text":"counts integer matrix (recent timepoint first row). baselines matrix positive entries (recent timepoint  first row). zones integer vector (zones concatenated; locations indexed  0 ). zone_lengths integer vector. outbreak_prob scalar; probability outbreak (time, place). alpha_null scalar; shape parameter gamma distribution null hypothesis anomaly. beta_null scalar; scale parameter gamma distribution null hypothesis anomaly. alpha_alt scalar; shape parameter gamma distribution alternative hypothesis anomaly. beta_alt scalar; scale parameter gamma distribution alternative hypothesis anomaly. inc_values vector possible values increase mean (variance) anomalous count. inc_probs vector prior probabilities value  inc_values.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_bayes_negbin_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the ","text":"list elements priors (list), posteriors (list),     marginal_data_prob (scalar). list priors     elements null_prior prior probability anomaly. alt_prior prior probability anomaly. inc_prior vector (matrix 1 row) prior probabilities                       value argument m_values. window_prior prior probability outbreak                          space-time windows. list posteriors elements null_posterior posterior probability anomaly. alt_posterior posterior probability anomaly. inc_posterior data frame columns inc_values                           inc_posterior. window_posteriors data frame columns zone,                                duration, log_posterior                                log_bayes_factor, row                                corresponding space-time window. space_time_posteriors matrix posterior anomaly                                    probability location-time                                    combination. location_posteriors vector (matrix 1 row)                                  posterior probability anomaly                                 location.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"Calculate expectation-based negative binomial scan statistic devised Tango et al. (2011).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"","code":"scan_eb_negbin(   counts,   zones,   baselines = NULL,   thetas = 1,   type = c(\"hotspot\", \"emerging\"),   n_mcsim = 0,   gumbel = FALSE,   max_only = FALSE )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional matrix          arguments baselines thetas also          specified. data frame columns \"time\", \"location\", \"count\", \"baseline\",         \"theta\". See description optional arguments          baselines thetas see definition. zones list integer vectors. vector corresponds single zone; elements numbers locations zone. baselines Optional. matrix dimensions counts.  Holds expected value parameter observed count.  parameters typically estimated past data using e.g. GLM. thetas Optional. matrix dimensions counts,  scalar. Holds dispersion parameter distribution,  \\(\\mu\\) expected value, variance  \\(\\mu+\\mu^2/\\theta\\). parameters typically estimated past  data using e.g. GLM. scalar supplied, dispersion parameter  assumed locations time points. type string, either \"hotspot\" \"emerging\". \"hotspot\", relative risk assumed fixed time. \"emerging\", relative risk assumed increase duration outbreak. n_mcsim non-negative integer; number replicate scan statistics generate order calculate \\(P\\)-value. gumbel Logical: Gumbel P-value calculated? Default FALSE. max_only Boolean. FALSE (default) statistic calculated zone duration returned. TRUE, largest  statistic (.e. scan statistic) returned, along  corresponding zone duration.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"list , addition information type scan    statistic, following components: MLC list containing number zone likely            cluster (MLC), locations zone, duration             MLC, calculated score. order,             elements list named  zone_number, locations,             duration, score. observed data frame containing, combination zone             duration investigated, zone number, duration, score.             table sorted score top-scoring location top.             max_only = TRUE, contains single row             corresponding MLC. replicates data frame Monte Carlo replicates scan             statistic (), corresponding zones durations. MC_pvalue Monte Carlo \\(P\\)-value. Gumbel_pvalue \\(P\\)-value obtained fitting Gumbel             distribution replicate scan statistics. n_zones number zones scanned. n_locations number locations. max_duration maximum duration considered. n_mcsim number Monte Carlo replicates made.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"Tango, T., Takahashi, K. & Kohriyama, K. (2011), space-time scan    statistic detecting emerging outbreaks, Biometrics 67(1), 106–115.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data  baselines <- matrix(rexp(n_total, 1/5), max_duration, n_locs)  thetas <- matrix(runif(n_total, 0.05, 3), max_duration, n_locs)  counts <- matrix(rnbinom(n_total,  mu = baselines,  size = thetas),                    max_duration, n_locs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- matrix(   rnbinom(ob_dur * length(ob_cols),            mu = 2 * baselines[ob_rows, ob_cols],           size = thetas[ob_rows, ob_cols]),   length(ob_rows), length(ob_cols)) res <- scan_eb_negbin(counts = counts,                       zones = zones,                       baselines = baselines,                       thetas = thetas,                       type = \"hotspot\",                       n_mcsim = 99,                       max_only = FALSE) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin_cpp","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin_cpp","text":"Calculate expectation-based negative binomial scan statistic Monte Carlo replicates.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin_cpp","text":"","code":"scan_eb_negbin_cpp(   counts,   baselines,   overdisp,   zones,   zone_lengths,   store_everything,   num_mcsim,   score_hotspot )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin_cpp","text":"counts Integer matrix (recent timepoint first row) baselines Matrix (recent timepoint first row) overdisp Matrix (recent timepoint first row) zones Integer vector (zones concatenated; locations indexed 0 ) zone_lengths Integer vector store_everything Boolean num_mcsim Integer score_hotspot Boolean","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_negbin_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expectation-based negative binomial scan statistic. — scan_eb_negbin_cpp","text":"list elements observed simulated,     data frame columns: zone top-scoring zone (spatial component MLC). duration corresponding duration (time-length MLC). score value loglihood ratio statistic (scan                   statistic). relrisk estimated relative risk. n_iter number iterations performed EM algorithm.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"Calculate expectation-based Poisson scan statistic devised Neill et  al. (2005).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"","code":"scan_eb_poisson(   counts,   zones,   baselines = NULL,   population = NULL,   n_mcsim = 0,   gumbel = FALSE,   max_only = FALSE )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional matrix argument          baselines also specified. data frame columns \"time\", \"location\", \"count\", \"baseline\".          Alternatively, column \"baseline\" can replaced column         \"population\". baselines expected values counts. zones list integer vectors. vector corresponds single zone; elements numbers locations zone. baselines Optional. matrix dimensions counts.  needed counts data frame. Holds Poisson mean  parameter observed count. estimated supplied  (requires population argument). parameters typically  estimated past data using e.g. Poisson (GLM) regression. population Optional. matrix vector populations  location. needed counts data frame. counts matrix, population needed baselines  estimated want account different populations  location (time). matrix, dimensions  counts. vector, length number  columns counts. n_mcsim non-negative integer; number replicate scan statistics generate order calculate \\(P\\)-value. gumbel Logical: Gumbel P-value calculated? Default FALSE. max_only Boolean. FALSE (default) log-likelihood ratio statistic zone duration returned. TRUE, largest statistic (.e. scan statistic) returned, along corresponding zone duration.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"list , addition information type scan    statistic, following components: MLC list containing number zone likely            cluster (MLC), locations zone, duration             MLC, calculated score, relative risk. order,             elements list named  zone_number, locations,             duration, score, relative_risk. observed data frame containing, combination zone             duration investigated, zone number, duration, score,             relative risk. table sorted score top-scoring             location top. max_only = TRUE, contains single             row corresponding MLC. replicates data frame Monte Carlo replicates scan             statistic (), corresponding zones durations. MC_pvalue Monte Carlo \\(P\\)-value. Gumbel_pvalue \\(P\\)-value obtained fitting Gumbel             distribution replicate scan statistics. n_zones number zones scanned. n_locations number locations. max_duration maximum duration considered. n_mcsim number Monte Carlo replicates made.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"Neill, D. B., Moore, . W., Sabhnani, M. Daniel, K. (2005).     Detection emerging space-time clusters. Proceeding     eleventh ACM SIGKDD international conference Knowledge discovery     data mining - KDD ’05, 218.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the expectation-based Poisson scan statistic. — scan_eb_poisson","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data baselines <- matrix(rexp(n_total, 1/5), max_duration, n_locs) counts <- matrix(rpois(n_total, as.vector(baselines)), max_duration, n_locs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- matrix(   rpois(ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols]),    length(ob_rows), length(ob_cols)) res <- scan_eb_poisson(counts = counts,                        zones = zones,                        baselines = baselines,                        n_mcsim = 99,                        max_only = FALSE) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expecation-based Poisson scan statistic. — scan_eb_poisson_cpp","title":"Calculate the expecation-based Poisson scan statistic. — scan_eb_poisson_cpp","text":"Calculate expectation-based Poisson scan statistic Monte Carlo  replicates.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expecation-based Poisson scan statistic. — scan_eb_poisson_cpp","text":"","code":"scan_eb_poisson_cpp(   counts,   baselines,   zones,   zone_lengths,   store_everything,   num_mcsim )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expecation-based Poisson scan statistic. — scan_eb_poisson_cpp","text":"counts integer matrix (recent timepoint first row). baselines matrix positive entries (recent timepoint  first row). zones integer vector (zones concatenated; locations indexed  0 ). zone_lengths integer vector. store_everything boolean. num_mcsim integer.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_poisson_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expecation-based Poisson scan statistic. — scan_eb_poisson_cpp","text":"list elements observed simulated,     data frame columns: zone top-scoring zone (spatial component MLC). duration corresponding duration (time-length MLC). score value loglihood ratio statistic (scan                   statistic). relrisk_in estimated relative risk inside. relrisk_in estimated relative risk outside.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"Calculates expectation-based scan statistic. See details .","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"","code":"scan_eb_zip(   counts,   zones,   baselines = NULL,   probs = NULL,   population = NULL,   n_mcsim = 0,   gumbel = FALSE,   max_only = FALSE,   rel_tol = 0.001 )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional matrix          arguments baselines probs also          specified. data frame columns \"time\", \"location\", \"count\", \"baseline\",         \"prob\". baselines expected values counts,          \"prob\" structural zero probabilities counts.         \"baseline\" \"prob\" found columns, values         estimated heuristic fashion (recommended).         population numbers available, can included          column \"population\" help estimation. zones list integer vectors. vector corresponds single zone; elements numbers locations zone. baselines Optional. matrix dimensions counts.  Holds Poisson mean parameter ZIP distribution observed  count. parameters typically estimated past data using e.g.  ZIP regression. probs Optional. matrix dimensions counts.  Holds structural zero probability ZIP distribution  observed count. parameters typically estimated past data  using e.g. ZIP regression. population Optional. matrix vector populations  location. needed baselines probs  estimated want account different populations  location (time). matrix, dimensions  counts. vector, length number  columns counts. n_mcsim non-negative integer; number replicate scan statistics generate order calculate \\(P\\)-value. gumbel Logical: Gumbel P-value calculated? Default FALSE. max_only Boolean. FALSE (default) log-likelihood ratio statistic zone duration returned. TRUE, largest statistic (.e. scan statistic) returned, along corresponding zone duration. rel_tol positive scalar. relative change incomplete information likelihood less value, EM algorithm deemed converged.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"list , addition information type scan    statistic, following components: MLC list containing number zone likely            cluster (MLC), locations zone, duration             MLC, calculated score, relative risk, number             iterations convergence EM algorithm. order,             elements list named  zone_number, locations,             duration, score, relative_risk, n_iter. observed data frame containing, combination zone             duration investigated, zone number, duration, score,             relative risk, number EM iterations. table sorted             score top-scoring location top.             max_only = TRUE, contains single row corresponding             MLC. replicates data frame Monte Carlo replicates scan             statistic (), corresponding zones durations. MC_pvalue Monte Carlo \\(P\\)-value. Gumbel_pvalue \\(P\\)-value obtained fitting Gumbel             distribution replicate scan statistics. n_zones number zones scanned. n_locations number locations. max_duration maximum duration considered. n_mcsim number Monte Carlo replicates made.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"expectation-based zero-inflated Poisson scan statistic    (Allévius & Höhle 2017), null hypothesis anomaly holds     count observed location \\(\\) duration \\(t\\) (    number time periods present) zero-inflated Poisson     distribution expected value parameter \\(\\mu_{}\\) structural     zero probability \\(p_{}\\):    $$      H_0 : Y_{} \\sim \\textrm{ZIP}(\\mu_{}, p_{}).    $$    holds locations \\(= 1, \\ldots, m\\) durations    \\(t = 1, \\ldots,T\\), \\(T\\) maximum duration considered.    alternative hypothesis, space-time window \\(W\\)    consisting spatial zone \\(Z \\subset \\{1, \\ldots, m\\}\\) time    window \\(D \\subseteq \\{1, \\ldots, T\\}\\) counts    window Poisson expected value parameters inflated factor    \\(q_W > 1\\) compared null hypothesis:    $$    H_1 : Y_{} \\sim \\textrm{ZIP}(q_W \\mu_{}, p_{}), ~~(,t) \\W.    $$    locations durations outside window, counts assumed    distributed null hypothesis. sets \\(Z\\) considered    specified argument zones, maximum    duration \\(T\\) taken maximum value column    duration input table. space-time window \\(W\\) considered, (log ) likelihood    ratio computed using distributions alternative null    hypotheses, expectation-based Poisson scan statistic calculated    maximum quantities space-time windows.    expectation-maximization (EM) algorithm used obtain maximum    likelihood estimates.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"Allévius, B. Höhle, M, expectation-based space-time scan     statistic ZIP-distributed data, (Technical report),    Link PDF.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the expectation-based ZIP scan statistic. — scan_eb_zip","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data baselines <- matrix(rexp(n_total, 1/5), max_duration, n_locs) probs <- matrix(runif(n_total) / 4, max_duration, n_locs) counts <- gamlss.dist::rZIP(n_total, baselines, probs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- gamlss.dist::rZIP(   ob_dur * length(ob_cols), 2 * baselines[ob_rows, ob_cols],    probs[ob_rows, ob_cols]) res <- scan_eb_zip(counts = counts,                    zones = zones,                    baselines = baselines,                    probs = probs,                    n_mcsim = 99,                    max_only = FALSE,                    rel_tol = 1e-3) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the highest-value EB ZIP loglihood ratio statistic. — scan_eb_zip_cpp","title":"Calculate the highest-value EB ZIP loglihood ratio statistic. — scan_eb_zip_cpp","text":"Calculate expectation-based ZIP loglihood ratio statistic zone duration, keep zone duration highest value (MLC). estimate relative risk also calculated, along number iterations EM algorithm performed.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the highest-value EB ZIP loglihood ratio statistic. — scan_eb_zip_cpp","text":"","code":"scan_eb_zip_cpp(   counts,   baselines,   probs,   zones,   zone_lengths,   rel_tol,   store_everything,   num_mcsim )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the highest-value EB ZIP loglihood ratio statistic. — scan_eb_zip_cpp","text":"counts matrix (recent timepoint first row) baselines matrix (recent timepoint first row) probs matrix (recent timepoint first row) zones integer vector (zones concatenated; locations indexed 0 ) zone_lengths integer vector rel_tol double store_everything boolean num_mcsim int","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_eb_zip_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the highest-value EB ZIP loglihood ratio statistic. — scan_eb_zip_cpp","text":"list elements observed simulated,     data frame columns: zone top-scoring zone (spatial component MLC). duration corresponding duration (time-length MLC). score value loglihood ratio statistic (scan                   statistic). relrisk estimated relative risk. n_iter number iterations performed EM algorithm.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_perm_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the space-time permutation scan statistic. — scan_pb_perm_cpp","title":"Calculate the space-time permutation scan statistic. — scan_pb_perm_cpp","text":"Calculate space-time permutation scan statistic (Kulldorff 2005)  Monte Carloo  replicates.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_perm_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the space-time permutation scan statistic. — scan_pb_perm_cpp","text":"","code":"scan_pb_perm_cpp(   counts,   baselines,   zones,   zone_lengths,   store_everything,   num_mcsim )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_perm_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the space-time permutation scan statistic. — scan_pb_perm_cpp","text":"counts integer matrix (recent timepoint first row). baselines matrix positive entries (recent timepoint  first row). zones integer vector (zones concatenated; locations indexed  0 ) zone_lengths integer vector. store_everything boolean. num_mcsim integer.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_perm_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the space-time permutation scan statistic. — scan_pb_perm_cpp","text":"list elements observed simulated,     data frame columns: zone top-scoring zone (spatial component MLC). duration corresponding duration (time-length MLC). score value loglihood ratio statistic (scan                   statistic). relrisk_in estimated relative risk inside. relrisk_in estimated relative risk outside.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"Calculate population-based Poisson scan statistic devised Kulldorff (1997, 2001).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"","code":"scan_pb_poisson(   counts,   zones,   population = NULL,   n_mcsim = 0,   gumbel = FALSE,   max_only = FALSE )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional argument          population also specified. data frame columns \"time\", \"location\", \"count\",          \"population\". zones list integer vectors. vector corresponds single zone; elements numbers locations zone. population Optional. matrix vector populations  location time point. needed baselines  estimated want account different populations  location (time). matrix, dimensions  counts. vector, length number  columns counts (number locations). n_mcsim non-negative integer; number replicate scan statistics generate order calculate P-value. gumbel Logical: Gumbel P-value calculated? Default FALSE. max_only Boolean. FALSE (default) log-likelihood ratio statistic zone duration returned. TRUE, largest statistic (.e. scan statistic) returned, along corresponding zone duration.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"list , addition information type scan    statistic, following components: MLC list containing number zone likely            cluster (MLC), locations zone, duration             MLC, calculated score, relative risk inside             outside cluster. order, elements list named              zone_number, locations, duration, score, relrisk_in,            relrisk_out. observed data frame containing, combination zone             duration investigated, zone number, duration, score,             relative risks. table sorted score top-scoring             location top. max_only = TRUE, contains single             row corresponding MLC. replicates data frame Monte Carlo replicates scan             statistic (), corresponding zones durations. MC_pvalue Monte Carlo \\(P\\)-value. Gumbel_pvalue \\(P\\)-value obtained fitting Gumbel             distribution replicate scan statistics. n_zones number zones scanned. n_locations number locations. max_duration maximum duration considered. n_mcsim number Monte Carlo replicates made.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"Kulldorff, M. (1997). spatial scan statistic. Communications     Statistics - Theory Methods, 26, 1481–1496. Kulldorff, M. (2001). Prospective time periodic geographical disease     surveillance using scan statistic. Journal Royal Statistical     Society, Series (Statistics Society), 164, 61–72.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data population <- matrix(rnorm(n_total, 100, 10), max_duration, n_locs) counts <- matrix(rpois(n_total, as.vector(population) / 20),                   max_duration, n_locs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- matrix(   rpois(ob_dur * length(ob_cols), 2 * population[ob_rows, ob_cols] / 20),    length(ob_rows), length(ob_cols)) res <- scan_pb_poisson(counts = counts,                        zones = zones,                        population = population,                        n_mcsim = 99,                        max_only = FALSE) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson_cpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson_cpp","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson_cpp","text":"Calculate population-based Poisson scan statistic Monte Carlo  replicates.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson_cpp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson_cpp","text":"","code":"scan_pb_poisson_cpp(   counts,   baselines,   zones,   zone_lengths,   store_everything,   num_mcsim )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson_cpp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson_cpp","text":"counts integer matrix (recent timepoint first row) baselines matrix (recent timepoint first row) zones integer vector (zones concatenated; locations indexed 0 ) zone_lengths integer vector store_everything boolean num_mcsim int","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_pb_poisson_cpp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the population-based Poisson scan statistic. — scan_pb_poisson_cpp","text":"list elements observed simulated,     data frame columns: zone top-scoring zone (spatial component MLC). duration corresponding duration (time-length MLC). score value loglihood ratio statistic (scan                   statistic). relrisk_in estimated relative risk inside. relrisk_in estimated relative risk outside.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the space-time permutation scan statistic. — scan_permutation","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"Calculate space-time permutation scan statistic devised Kulldorff (2005).","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"","code":"scan_permutation(   counts,   zones,   population = NULL,   n_mcsim = 0,   gumbel = FALSE,   max_only = FALSE )"},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"counts Either: matrix observed counts. Rows indicate time ordered         least recent (row 1) recent (row          nrow(counts)). Columns indicate locations, numbered 1          . counts matrix, optional argument          population also specified. data frame columns \"time\", \"location\", \"count\",          \"population\". zones list integer vectors. vector corresponds single zone; elements numbers locations zone. population Optional. matrix vector populations  location time point. needed baselines  estimated want account different populations  location (time). matrix, dimensions  counts. vector, length number  columns counts (number locations). n_mcsim non-negative integer; number replicate scan statistics generate order calculate P-value. gumbel Logical: Gumbel P-value calculated? Default FALSE. max_only Boolean. FALSE (default) log-likelihood ratio statistic zone duration returned. TRUE, largest statistic (.e. scan statistic) returned, along corresponding zone duration.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"list , addition information type scan    statistic, following components: MLC list containing number zone likely            cluster (MLC), locations zone, duration             MLC, calculated score, relative risk inside             outside cluster. order, elements list named              zone_number, locations, duration, score, relrisk_in,            relrisk_out. observed data frame containing, combination zone             duration investigated, zone number, duration, score,             relative risks. table sorted score top-scoring             location top. max_only = TRUE, contains single             row corresponding MLC. replicates data frame Monte Carlo replicates scan             statistic (), corresponding zones durations. MC_pvalue Monte Carlo \\(P\\)-value. Gumbel_pvalue \\(P\\)-value obtained fitting Gumbel             distribution replicate scan statistics. n_zones number zones scanned. n_locations number locations. max_duration maximum duration considered. n_mcsim number Monte Carlo replicates made.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"Kulldorff, M., Heffernan, R., Hartman, J., Assunção, R. M., Mostashari, F.    (2005). space-time permutation scan statistic disease outbreak     detection. PLoS Medicine, 2(3), 0216-0224.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/scan_permutation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the space-time permutation scan statistic. — scan_permutation","text":"","code":"if (FALSE) { set.seed(1) # Create location coordinates, calculate nearest neighbors, and create zones n_locs <- 50 max_duration <- 5 n_total <- n_locs * max_duration geo <- matrix(rnorm(n_locs * 2), n_locs, 2) knn_mat <- coords_to_knn(geo, 15) zones <- knn_zones(knn_mat)  # Simulate data population <- matrix(rnorm(n_total, 100, 10), max_duration, n_locs) counts <- matrix(rpois(n_total, as.vector(population) / 20),                   max_duration, n_locs)  # Inject outbreak/event/anomaly ob_dur <- 3 ob_cols <- zones[[10]] ob_rows <- max_duration + 1 - seq_len(ob_dur) counts[ob_rows, ob_cols] <- matrix(   rpois(ob_dur * length(ob_cols), 2 * population[ob_rows, ob_cols] / 20),    length(ob_rows), length(ob_cols)) res <- scan_permutation(counts = counts,                            zones = zones,                            population = population,                            n_mcsim = 99,                            max_only = FALSE) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/score_locations.html","id":null,"dir":"Reference","previous_headings":"","what":"Score each location over zones and duration. — score_locations","title":"Score each location over zones and duration. — score_locations","text":"location, compute average statistic calculated space-time window location included , .e. average  statistic zones maximum duration.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/score_locations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Score each location over zones and duration. — score_locations","text":"","code":"score_locations(x, zones)"},{"path":"https://promerpr.github.io/scanstatistics/reference/score_locations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Score each location over zones and duration. — score_locations","text":"x object class scanstatistic. zones list integer vectors.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/score_locations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Score each location over zones and duration. — score_locations","text":"data.table following columns: location locations (integers). total_score location, sum window statistics                          location appears . n_zones number spatial zones location appears                      . score total score divided number zones                    maximum duration. relative_score score divided maximum score.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/score_locations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Score each location over zones and duration. — score_locations","text":"","code":"if (FALSE) { # Simple example set.seed(1) table <- data.frame(zone = 1:5, duration = 1, score = 5:1) zones <- list(1:2, 1:3, 2:5, 4:5, c(1, 5)) x <- list(table = table, n_locations = 5, max_duration = 1, n_zones = 5) score_locations(x, zones) }"},{"path":"https://promerpr.github.io/scanstatistics/reference/top_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the top (non-overlappig) clusters. — top_clusters","title":"Get the top (non-overlappig) clusters. — top_clusters","text":"Get top \\(k\\) space-time clusters according statistic calculated cluster (maximum scan statistic). default  return spatially non-overlapping clusters, .e.  locations common.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/top_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the top (non-overlappig) clusters. — top_clusters","text":"","code":"top_clusters(   x,   zones,   k = 5,   overlapping = FALSE,   gumbel = FALSE,   alpha = NULL,   ... )"},{"path":"https://promerpr.github.io/scanstatistics/reference/top_clusters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the top (non-overlappig) clusters. — top_clusters","text":"x object class scanstatistics. zones list integer vectors. k integer, number clusters return. overlapping Logical; top clusters allowed overlap spatial dimension? default FALSE. gumbel Logical; Gumbel P-value calculated? default  FALSE. alpha significance level, NULL used calculate critical value statistics table. ... Parameters passed quantile.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/top_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the top (non-overlappig) clusters. — top_clusters","text":"data frame \\(k\\) rows, columns  zone, duration, score possibly MC_pvalue, Gumbel_pvalue   critical_value.","code":""},{"path":"https://promerpr.github.io/scanstatistics/reference/top_clusters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the top (non-overlappig) clusters. — top_clusters","text":"","code":"if (FALSE) { set.seed(1) counts <- matrix(rpois(15, 3), 3, 5) zones <- list(1:2, 1:3, 2:5, c(1, 3), 4:5, c(1, 5)) scanres <- scan_permutation(counts, zones, n_mcsim = 5) top_clusters(scanres, zones, k = 4, overlapping = FALSE) }"},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/news/index.html","id":"minor-changes-1-1-0","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"scanstatistics 1.1.0","text":"Switched maintainer associated urls. Fixes compiler warnings; needed restore package CRAN. Removed dependence reliaR (package longer CRAN) Fixed bug scan_eb_negbin","code":""},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/news/index.html","id":"minor-changes-1-0-2","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"scanstatistics 1.0.2","text":"Removed unneeded internal functions caused package loaded. Added CITATION file updated citation package. Fixes multiple bugs found Kelly Reeve. Added functionality function top_clusters.","code":""},{"path":"https://promerpr.github.io/scanstatistics/news/index.html","id":"scanstatistics-101","dir":"Changelog","previous_headings":"","what":"scanstatistics 1.0.1","title":"scanstatistics 1.0.1","text":"CRAN release: 2018-01-24 Fixes compiler warnings; needed keep package CRAN.","code":""},{"path":[]},{"path":"https://promerpr.github.io/scanstatistics/news/index.html","id":"major-changes-1-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"scanstatistics 1.0","text":"New interface main functions: accept data frames matrices instead data tables. scan statistics reimplemented C++. Several new scan statistics available.","code":""},{"path":"https://promerpr.github.io/scanstatistics/news/index.html","id":"minor-changes-1-0","dir":"Changelog","previous_headings":"Major changes","what":"Minor changes","title":"scanstatistics 1.0","text":"functions knn_zones flexible_zones now run faster due change algorithms.","code":""},{"path":[]}]
